#!/usr/bin/env python3
"""
Script para hacer predicciones con el modelo YOLOv8n entrenado para logos deportivos
Soporta:
- Predicciones en im√°genes individuales
- Predicciones en carpetas de im√°genes
- Predicciones en archivos de video
- Predicciones en tiempo real con webcam

Autor: Juan Carlos Mac√≠as / Copilot
Fecha: Agosto 2025
"""

import os
import sys
from pathlib import Path
import cv2
import numpy as np
from ultralytics import YOLO
import matplotlib.pyplot as plt
import argparse
import yaml

class LogoPredictor:
    def __init__(self, model_path="runs/detect/modelo_entreno_2025-08-30_19-19-42-687094/weights/best.pt"):
        """
        Inicializar el predictor de logos
        
        Args:
            model_path: Ruta al modelo entrenado (.pt o .onnx)
        """
        self.model_path = Path(model_path)
        if not self.model_path.exists():
            raise FileNotFoundError(f"No se encontr√≥ el modelo en: {model_path}")
        
        print(f"ü§ñ Cargando modelo desde: {self.model_path}")
        self.model = YOLO(str(self.model_path))

        # Obtener nombres de clases din√°micamente del modelo
        self.class_names = self.get_model_classes()
        
        print(f"‚úÖ Modelo cargado correctamente")
        print(f"üìã Clases detectadas en el modelo: {len(self.class_names)}")
        print(f"üè∑Ô∏è  Marcas disponibles: {list(self.class_names.values())}")

    def get_model_classes(self):
        """
        Obtener las clases del modelo de forma din√°mica
        
        Returns:
            dict: Diccionario con {id: nombre_clase}
        """
        try:
            # M√©todo 1: Desde model.names (m√°s directo)
            if hasattr(self.model, 'names') and self.model.names:
                print("üìã Clases obtenidas desde model.names")
                return self.model.names
            
            # M√©todo 2: Desde model.model.names
            elif hasattr(self.model.model, 'names') and self.model.model.names:
                print("üìã Clases obtenidas desde model.model.names")
                return self.model.model.names
            
            # M√©todo 3: Hacer una predicci√≥n dummy para cargar las clases
            elif hasattr(self.model, 'predict'):
                print("üìã Cargando clases mediante predicci√≥n dummy...")
                # Crear imagen dummy de 1x1 pixel
                dummy_img = np.zeros((1, 1, 3), dtype=np.uint8)
                temp_results = self.model.predict(dummy_img, verbose=False)
                if temp_results and hasattr(temp_results[0], 'names'):
                    return temp_results[0].names
            
            # M√©todo 4: Desde el archivo de configuraci√≥n del dataset
            config_path = Path("dataset/config.yaml")
            if config_path.exists():
                print("üìã Cargando clases desde dataset/config.yaml")
                import yaml
                with open(config_path, 'r', encoding='utf-8') as f:
                    config = yaml.safe_load(f)
                    if 'names' in config:
                        # Convertir lista a diccionario con √≠ndices
                        if isinstance(config['names'], list):
                            return {i: name for i, name in enumerate(config['names'])}
                        elif isinstance(config['names'], dict):
                            return config['names']
            
            # Fallback: Clases por defecto basadas en el proyecto
            print("‚ö†Ô∏è  Usando clases por defecto del proyecto")
            return {
                0: 'adidas',
                1: 'adidas_1',
                2: 'adidas_2',
                3: 'nike', 
                4: 'puma'
            }
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Error obteniendo clases del modelo: {e}")
            print("üìã Usando clases por defecto")
            return {
                0: 'adidas',
                1: 'adidas_1',
                2: 'adidas_2',
                3: 'nike', 
                4: 'puma'
            }

    def predict_image(self, image_path, conf_threshold=0.5, save_results=True):
        """
        Hacer predicci√≥n en una imagen espec√≠fica
        
        Args:
            image_path: Ruta a la imagen
            conf_threshold: Umbral de confianza (0.0 - 1.0)
            save_results: Si guardar los resultados
        
        Returns:
            results: Resultados de la predicci√≥n
        """
        image_path = Path(image_path)
        
        if not image_path.exists():
            raise FileNotFoundError(f"No se encontr√≥ la imagen: {image_path}")
        
        print(f"\nüîç Analizando imagen: {image_path.name}")
        
        # Hacer predicci√≥n

        results = self.model.predict(
            source=str(image_path),
            conf=0.35,          # m√°s recall
            iou=0.6,            # mejor filtrado
            max_det=300,
            save=save_results,
            project="runs/predict",
            name="logo_prediction",
            exist_ok=True,
            verbose=False
        )
        # Procesar resultados
        self.process_results(results[0], image_path)
        
        return results[0]
    
    def process_results(self, result, image_path):
        """
        Procesar y mostrar los resultados de la predicci√≥n
        
        Args:
            result: Resultado de YOLO
            image_path: Ruta de la imagen original
        """
        # Obtener detecciones
        boxes = result.boxes
        
        if boxes is None or len(boxes) == 0:
            print("‚ùå No se detectaron logos en la imagen")
            return
        
        print(f"‚úÖ Se detectaron {len(boxes)} logo(s):")
        print("-" * 50)
        
        for i, box in enumerate(boxes):
            # Obtener informaci√≥n de la detecci√≥n
            confidence = float(box.conf[0])
            class_id = int(box.cls[0])
            class_name = self.get_class_name(class_id)
            
            # Coordenadas de la caja
            x1, y1, x2, y2 = box.xyxy[0].tolist()
            
            print(f"üìç Logo {i+1}:")
            print(f"   üè∑Ô∏è  Marca: {class_name}")
            print(f"   üéØ Confianza: {confidence:.2%}")
            print(f"   üì¶ Coordenadas: ({int(x1)}, {int(y1)}) - ({int(x2)}, {int(y2)})")
            print()
    
    def predict_multiple_images(self, folder_path, conf_threshold=0.5):
        """
        Hacer predicciones en m√∫ltiples im√°genes de una carpeta
        
        Args:
            folder_path: Ruta a la carpeta con im√°genes
            conf_threshold: Umbral de confianza
        """
        folder_path = Path(folder_path)
        
        if not folder_path.exists():
            raise FileNotFoundError(f"No se encontr√≥ la carpeta: {folder_path}")
        
        # Extensiones de imagen soportadas
        image_extensions = {'.jpg', '.jpeg', '.png', '.bmp', '.tiff', '.webp'}
        
        # Encontrar todas las im√°genes
        image_files = []
        for ext in image_extensions:
            image_files.extend(folder_path.glob(f"*{ext}"))
            image_files.extend(folder_path.glob(f"*{ext.upper()}"))
        
        if not image_files:
            print(f"‚ùå No se encontraron im√°genes en: {folder_path}")
            return
        
        print(f"üîç Procesando {len(image_files)} im√°genes...")
        
        results_summary = {name: 0 for name in self.class_names.values()}
        
        for img_path in image_files:
            print(f"\n{'='*60}")
            result = self.predict_image(img_path, conf_threshold, save_results=True)
            
            # Contar detecciones por clase
            if result.boxes is not None:
                for box in result.boxes:
                    class_id = int(box.cls[0])
                    class_name = self.class_names.get(class_id, f"Clase_{class_id}")
                    results_summary[class_name] += 1
        
        # Mostrar resumen
        print(f"\n{'='*60}")
        print("üìä RESUMEN DE DETECCIONES:")
        print("-" * 30)
        total_detections = sum(results_summary.values())
        
        for brand, count in results_summary.items():
            if count > 0:
                percentage = (count / total_detections) * 100
                print(f"üè∑Ô∏è  {brand}: {count} detecciones ({percentage:.1f}%)")
        
        print(f"\nüéØ Total de logos detectados: {total_detections}")
        print(f"üìÅ Resultados guardados en: runs/predict/logo_prediction/")
    
    def predict_video(self, video_path, conf_threshold=0.5, save_video=True):
        """
        Hacer predicciones en un archivo de video
        
        Args:
            video_path: Ruta al archivo de video
            conf_threshold: Umbral de confianza
            save_video: Si guardar el video con detecciones
        """
        video_path = Path(video_path)
        
        if not video_path.exists():
            raise FileNotFoundError(f"No se encontr√≥ el video: {video_path}")
        
        print(f"üé• Analizando video: {video_path.name}")
        print("Presiona 'q' para salir durante la reproducci√≥n")
        
        # Hacer predicci√≥n en video
        results = self.model.predict(
            source=str(video_path),
            conf=0.25,          # m√°s recall
            iou=0.6,            # mejor filtrado
            max_det=300,
            show=True,
            save=save_video,
            project="runs/predict",
            name="logo_prediction",
            exist_ok=True,
            verbose=False
        )
        #print(f" Resultados: {results}")
        if save_video:
            print(f"‚úÖ Video procesado guardado en: runs/predict/video_prediction/")
    
    def predict_webcam(self, conf_threshold=0.5):
        """
        Hacer predicciones en tiempo real desde la webcam
        
        Args:
            conf_threshold: Umbral de confianza
        """
        print("üé• Iniciando detecci√≥n en tiempo real desde webcam...")
        print("Presiona 'q' para salir")
        
        # Hacer predicci√≥n en tiempo real
        results = self.model.predict(
            source=0,  # Webcam
            conf=conf_threshold,
            show=True,
            save=False
        )
    
    def show_model_info(self):
        """
        Mostrar informaci√≥n del modelo
        """
        print("\nü§ñ INFORMACI√ìN DEL MODELO:")
        print("-" * 40)
        print(f"üìÅ Archivo: {self.model_path}")
        print(f"üìä Clases: {len(self.class_names)}")
        print(f"üè∑Ô∏è  Marcas detectables:")
        for i, name in self.class_names.items():
            print(f"   {i}: {name}")
        print()

    def list_classes(self):
        """
        Listar todas las clases disponibles en el modelo
        
        Returns:
            dict: Diccionario con las clases {id: nombre}
        """
        print("\nüìã CLASES DISPONIBLES EN EL MODELO:")
        print("=" * 45)
        
        for class_id, class_name in self.class_names.items():
            print(f"üè∑Ô∏è  ID: {class_id:2d} ‚Üí Nombre: '{class_name}'")
        
        print(f"\nüìä Total de clases: {len(self.class_names)}")
        print("=" * 45)
        
        return self.class_names

    def get_class_name(self, class_id):
        """
        Obtener el nombre de una clase por su ID
        
        Args:
            class_id: ID de la clase
            
        Returns:
            str: Nombre de la clase
        """
        return self.class_names.get(class_id, f"Clase_desconocida_{class_id}")

    def get_class_id(self, class_name):
        """
        Obtener el ID de una clase por su nombre
        
        Args:
            class_name: Nombre de la clase
            
        Returns:
            int: ID de la clase (None si no se encuentra)
        """
        for class_id, name in self.class_names.items():
            if name.lower() == class_name.lower():
                return class_id
        return None


def main():
    """Funci√≥n principal"""
    parser = argparse.ArgumentParser(description="Predictor de logos deportivos con YOLOv8")
    parser.add_argument("--image", "-i", type=str, help="Ruta a la imagen para analizar")
    parser.add_argument("--folder", "-f", type=str, help="Ruta a carpeta con im√°genes")
    parser.add_argument("--video", "-v", type=str, help="Ruta al archivo de video para analizar")
    parser.add_argument("--webcam", "-w", action="store_true", help="Usar webcam en tiempo real")
    parser.add_argument("--model", "-m", type=str, default="runs/detect/modelo_entrenado_v4/weights/best.pt", 
                       help="Ruta al modelo entrenado")
    parser.add_argument("--conf", "-c", type=float, default=0.5, 
                       help="Umbral de confianza (0.0-1.0)")
    parser.add_argument("--info", action="store_true", help="Mostrar informaci√≥n del modelo")
    parser.add_argument("--classes", action="store_true", help="Listar todas las clases disponibles")
    parser.add_argument("--no-save", action="store_true", help="No guardar el video procesado")
    
    args = parser.parse_args()
    
    try:
        # Crear predictor
        predictor = LogoPredictor(args.model)
        
        if args.info:
            predictor.show_model_info()
            return
        
        if args.classes:
            predictor.list_classes()
            return
        
        if args.image:
            # Predicci√≥n en imagen √∫nica
            predictor.predict_image(args.image, args.conf)
            print(f"\n‚úÖ Resultado guardado en: runs/predict/logo_prediction/")
            
        elif args.folder:
            # Predicci√≥n en m√∫ltiples im√°genes
            predictor.predict_multiple_images(args.folder, args.conf)
            
        elif args.video:
            # Predicci√≥n en video
            save_video = not args.no_save
            predictor.predict_video(args.video, args.conf, save_video)
            
        elif args.webcam:
            # Predicci√≥n en tiempo real
            predictor.predict_webcam(args.conf)
            
        else:
            # Modo interactivo
            print("\nüéØ PREDICTOR DE LOGOS DEPORTIVOS")
            print("=" * 40)
            predictor.show_model_info()
            
            while True:
                print("\nüìã OPCIONES:")
                print("1. Analizar una imagen")
                print("2. Analizar carpeta de im√°genes")
                print("3. Analizar un video")
                print("4. Webcam en tiempo real")
                print("5. Informaci√≥n del modelo")
                print("6. Listar clases disponibles")
                print("0. Salir")
                
                choice = input("\nüî∏ Selecciona una opci√≥n (0-6): ").strip()
                
                if choice == "0":
                    print("üëã ¬°Hasta luego!")
                    break
                    
                elif choice == "1":
                    img_path = input("üìÅ Ruta de la imagen: ").strip()
                    if img_path:
                        try:
                            predictor.predict_image(img_path, args.conf)
                            print(f"\n‚úÖ Resultado guardado en: runs/predict/logo_prediction/")
                        except Exception as e:
                            print(f"‚ùå Error: {e}")
                
                elif choice == "2":
                    folder_path = input("üìÅ Ruta de la carpeta: ").strip()
                    if folder_path:
                        try:
                            predictor.predict_multiple_images(folder_path, args.conf)
                        except Exception as e:
                            print(f"‚ùå Error: {e}")
                
                elif choice == "3":
                    video_path = input("üìÅ Ruta del video: ").strip()
                    if video_path:
                        try:
                            save_video = input("üíæ ¬øGuardar video procesado? (s/N): ").strip().lower() == 's'
                            predictor.predict_video(video_path, args.conf, save_video)
                        except Exception as e:
                            print(f"‚ùå Error: {e}")
                
                elif choice == "4":
                    try:
                        predictor.predict_webcam(args.conf)
                    except Exception as e:
                        print(f"‚ùå Error: {e}")
                
                elif choice == "5":
                    predictor.show_model_info()
                
                elif choice == "6":
                    predictor.list_classes()
                
                else:
                    print("‚ùå Opci√≥n no v√°lida")
    
    except Exception as e:
        print(f"‚ùå Error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
